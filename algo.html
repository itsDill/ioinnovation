<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Trading Dashboard</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap"
      rel="stylesheet"
    />

    <!-- Font Awesome -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    />

    <!-- Chart.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>

    <style>
      :root {
        --primary-color: #3b82f6;
        --secondary-color: #1e293b;
        --success-color: #10b981;
        --danger-color: #ef4444;
        --warning-color: #f59e0b;
        --info-color: #06b6d4;
        --background: #0f172a;
        --surface: #1e293b;
        --surface-light: #334155;
        --text-primary: #f1f5f9;
        --text-secondary: #94a3b8;
        --text-muted: #64748b;
        --border: #334155;
        --gradient-primary: linear-gradient(135deg, #3b82f6, #1d4ed8);
        --gradient-success: linear-gradient(135deg, #10b981, #059669);
        --gradient-danger: linear-gradient(135deg, #ef4444, #dc2626);
        --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", sans-serif;
        background: var(--background);
        color: var(--text-primary);
        line-height: 1.6;
        overflow-x: hidden;
      }

      .dashboard {
        display: grid;
        grid-template-columns: 280px 1fr;
        min-height: 100vh;
      }

      /* Sidebar */
      .sidebar {
        background: var(--surface);
        border-right: 1px solid var(--border);
        padding: 2rem 0;
        position: sticky;
        top: 0;
        height: 100vh;
      }

      .sidebar-header {
        padding: 0 2rem 2rem;
        border-bottom: 1px solid var(--border);
        margin-bottom: 2rem;
      }

      .sidebar-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: 0.5rem;
      }

      .sidebar-subtitle {
        color: var(--text-muted);
        font-size: 0.875rem;
      }

      .sidebar-nav {
        padding: 0 1rem;
      }

      .nav-item {
        margin-bottom: 0.5rem;
      }

      .nav-link {
        display: flex;
        align-items: center;
        padding: 0.75rem 1rem;
        color: var(--text-secondary);
        text-decoration: none;
        border-radius: 8px;
        transition: all 0.3s ease;
        font-weight: 500;
      }

      .nav-link:hover,
      .nav-link.active {
        background: var(--primary-color);
        color: white;
        transform: translateX(4px);
      }

      .nav-link i {
        margin-right: 0.75rem;
        width: 20px;
        text-align: center;
      }

      /* Main Content */
      .main-content {
        padding: 2rem;
        background: var(--background);
        overflow-y: auto;
      }

      .dashboard-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 2rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid var(--border);
      }

      .dashboard-title {
        font-size: 2rem;
        font-weight: 700;
        color: var(--text-primary);
      }

      .dashboard-actions {
        display: flex;
        gap: 1rem;
        align-items: center;
      }

      .status-indicator {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        background: var(--surface);
        border-radius: 8px;
        font-size: 0.875rem;
        font-weight: 500;
      }

      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--warning-color);
        animation: pulse 2s infinite;
      }

      .status-dot.connected {
        background: var(--success-color);
      }

      .status-dot.disconnected {
        background: var(--danger-color);
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .card {
        background: var(--surface);
        border-radius: 12px;
        padding: 1.5rem;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
        transition: all 0.3s ease;
        margin-bottom: 1.5rem;
      }

      .card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-lg);
      }

      .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
      }

      .card-title {
        font-size: 1.125rem;
        font-weight: 600;
        color: var(--text-primary);
      }

      .card-subtitle {
        color: var(--text-muted);
        font-size: 0.875rem;
      }

      .card-actions {
        display: flex;
        gap: 0.5rem;
      }

      .btn {
        padding: 0.5rem 1rem;
        border: none;
        border-radius: 6px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        text-decoration: none;
        font-size: 0.875rem;
      }

      .btn-sm {
        padding: 0.25rem 0.75rem;
        font-size: 0.75rem;
      }

      .btn-primary {
        background: var(--gradient-primary);
        color: white;
      }

      .btn-secondary {
        background: var(--surface-light);
        color: var(--text-secondary);
      }

      .btn:hover {
        transform: translateY(-1px);
        box-shadow: var(--shadow);
      }

      /* Stats Grid */
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
        margin-bottom: 2rem;
      }

      .stat-card {
        padding: 1.5rem;
        background: var(--surface-light);
        border-radius: 8px;
        text-align: center;
        border: 1px solid var(--border);
        transition: all 0.3s ease;
      }

      .stat-card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow);
      }

      .stat-value {
        font-size: 1.75rem;
        font-weight: 700;
        font-family: "JetBrains Mono", monospace;
        margin-bottom: 0.5rem;
        color: var(--text-primary);
      }

      .stat-label {
        font-size: 0.875rem;
        color: var(--text-muted);
        font-weight: 500;
      }

      .stat-change {
        font-size: 0.75rem;
        margin-top: 0.25rem;
        font-weight: 600;
      }

      .stat-change.positive {
        color: var(--success-color);
      }

      .stat-change.negative {
        color: var(--danger-color);
      }

      /* Signal Log */
      .signal-log {
        max-height: 400px;
        overflow-y: auto;
        background: var(--background);
        border-radius: 8px;
        padding: 1rem;
        border: 1px solid var(--border);
      }

      .signal-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 0;
        border-bottom: 1px solid var(--border);
      }

      .signal-item:last-child {
        border-bottom: none;
      }

      .signal-left {
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .signal-type {
        padding: 0.25rem 0.75rem;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        min-width: 60px;
        text-align: center;
      }

      .signal-buy {
        background: rgba(16, 185, 129, 0.2);
        color: var(--success-color);
      }

      .signal-sell {
        background: rgba(239, 68, 68, 0.2);
        color: var(--danger-color);
      }

      .signal-hold {
        background: rgba(245, 158, 11, 0.2);
        color: var(--warning-color);
      }

      .signal-price {
        font-weight: 600;
        font-family: "JetBrains Mono", monospace;
        color: var(--text-primary);
      }

      .signal-strength {
        color: var(--text-muted);
        font-size: 0.875rem;
      }

      .signal-time {
        font-family: "JetBrains Mono", monospace;
        font-size: 0.875rem;
        color: var(--text-muted);
      }

      .chart-container {
        position: relative;
        height: 400px;
        margin-top: 1rem;
      }

      .data-status {
        padding: 1rem;
        background: var(--surface-light);
        border-radius: 8px;
        border-left: 4px solid var(--warning-color);
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .data-status.connected {
        border-left-color: var(--success-color);
      }

      .data-status.error {
        border-left-color: var(--danger-color);
      }

      .empty-state {
        text-align: center;
        color: var(--text-muted);
        padding: 2rem;
        font-style: italic;
      }

      /* Performance Metrics */
      .performance-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        margin-top: 1rem;
      }

      .performance-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 0;
        border-bottom: 1px solid var(--border);
      }

      .performance-item:last-child {
        border-bottom: none;
      }

      .performance-label {
        color: var(--text-secondary);
        font-size: 0.875rem;
      }

      .performance-value {
        font-family: "JetBrains Mono", monospace;
        font-weight: 600;
        color: var(--text-primary);
      }

      /* Responsive Design */
      @media (max-width: 1024px) {
        .dashboard {
          grid-template-columns: 1fr;
        }

        .sidebar {
          position: relative;
          width: 100%;
          height: auto;
        }

        .stats-grid {
          grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        }

        .performance-grid {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 640px) {
        .main-content {
          padding: 1rem;
        }

        .dashboard-header {
          flex-direction: column;
          gap: 1rem;
          align-items: flex-start;
        }

        .dashboard-actions {
          width: 100%;
          justify-content: space-between;
        }
      }
    </style>
  </head>
  <body>
    <div class="dashboard">
      <!-- Sidebar -->
      <div class="sidebar">
        <div class="sidebar-header">
          <h2 class="sidebar-title">Trading Dashboard</h2>
          <p class="sidebar-subtitle">Live Market Data</p>
        </div>

        <nav class="sidebar-nav">
          <div class="nav-item">
            <a href="#" class="nav-link active" data-section="overview">
              <i class="fas fa-chart-line"></i>
              Overview
            </a>
          </div>
          <div class="nav-item">
            <a href="#" class="nav-link" data-section="signals">
              <i class="fas fa-signal"></i>
              Signals
            </a>
          </div>
          <div class="nav-item">
            <a href="#" class="nav-link" data-section="performance">
              <i class="fas fa-chart-bar"></i>
              Performance
            </a>
          </div>
          <div class="nav-item">
            <a href="#" class="nav-link" data-section="data">
              <i class="fas fa-database"></i>
              Data Sources
            </a>
          </div>
        </nav>
      </div>

      <!-- Main Content -->
      <div class="main-content">
        <div class="dashboard-header">
          <h1 class="dashboard-title">Market Overview</h1>
          <div class="dashboard-actions">
            <div class="status-indicator">
              <div class="status-dot" id="connection-status"></div>
              <span id="connection-text">Connecting...</span>
            </div>
            <div class="status-indicator">
              <div class="status-dot" id="algo-status"></div>
              <span id="algo-text">Algorithm Status</span>
            </div>
          </div>
        </div>

        <!-- Data Connection Status -->
        <div class="data-status" id="data-status">
          <i class="fas fa-server"></i>
          <div>
            <strong>Data Connection:</strong>
            <span id="data-status-text">Initializing connection...</span>
          </div>
        </div>

        <!-- Key Metrics -->
        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-value" id="current-price">$0.00</div>
            <div class="stat-label">Current Price</div>
            <div class="stat-change" id="price-change">--</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="total-signals">0</div>
            <div class="stat-label">Total Signals</div>
            <div class="stat-change" id="signals-change">--</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="success-rate">--%</div>
            <div class="stat-label">Success Rate</div>
            <div class="stat-change" id="success-change">--</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="last-signal">--</div>
            <div class="stat-label">Last Signal</div>
            <div class="stat-change" id="signal-time">--</div>
          </div>
        </div>

        <!-- Price Chart -->
        <div class="card">
          <div class="card-header">
            <div>
              <h3 class="card-title">Price Chart</h3>
              <div class="card-subtitle">Real-time market data</div>
            </div>
            <div class="card-actions">
              <button
                class="btn btn-secondary btn-sm"
                onclick="toggleTimeframe('1h')"
              >
                1H
              </button>
              <button
                class="btn btn-secondary btn-sm"
                onclick="toggleTimeframe('4h')"
              >
                4H
              </button>
              <button
                class="btn btn-secondary btn-sm"
                onclick="toggleTimeframe('1d')"
              >
                1D
              </button>
            </div>
          </div>
          <div class="chart-container">
            <canvas id="priceChart"></canvas>
          </div>
        </div>

        <!-- Signal History -->
        <div class="card">
          <div class="card-header">
            <div>
              <h3 class="card-title">Recent Signals</h3>
              <div class="card-subtitle">
                Latest trading signals from backend
              </div>
            </div>
            <div class="card-actions">
              <button
                class="btn btn-secondary btn-sm"
                onclick="refreshSignals()"
              >
                <i class="fas fa-refresh"></i>
                Refresh
              </button>
            </div>
          </div>
          <div class="signal-log" id="signal-log">
            <div class="empty-state">
              <i
                class="fas fa-signal"
                style="font-size: 2rem; margin-bottom: 1rem; opacity: 0.5"
              ></i>
              <div>No signals received yet</div>
              <div style="font-size: 0.875rem; margin-top: 0.5rem">
                Waiting for backend algorithm...
              </div>
            </div>
          </div>
        </div>

        <!-- Performance Metrics -->
        <div class="card">
          <div class="card-header">
            <h3 class="card-title">Performance Metrics</h3>
            <div class="card-subtitle">Algorithm performance statistics</div>
          </div>
          <div class="performance-grid">
            <div>
              <div class="performance-item">
                <span class="performance-label">Win Rate</span>
                <span class="performance-value" id="win-rate">--%</span>
              </div>
              <div class="performance-item">
                <span class="performance-label">Avg. Hold Time</span>
                <span class="performance-value" id="avg-hold-time">--</span>
              </div>
              <div class="performance-item">
                <span class="performance-label">Best Signal</span>
                <span class="performance-value" id="best-signal">--</span>
              </div>
            </div>
            <div>
              <div class="performance-item">
                <span class="performance-label">Total Trades</span>
                <span class="performance-value" id="total-trades">0</span>
              </div>
              <div class="performance-item">
                <span class="performance-label">Active Since</span>
                <span class="performance-value" id="active-since">--</span>
              </div>
              <div class="performance-item">
                <span class="performance-label">Last Update</span>
                <span class="performance-value" id="last-update">--</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Dashboard Manager - Frontend Only
      class DashboardManager {
        constructor() {
          this.isConnected = false;
          this.lastUpdate = null;
          this.signals = [];
          this.priceData = [];
          this.currentPrice = 0;

          this.initializeChart();
          this.startDataPolling();
        }

        initializeChart() {
          const ctx = document.getElementById("priceChart").getContext("2d");
          this.chart = new Chart(ctx, {
            type: "line",
            data: {
              labels: [],
              datasets: [
                {
                  label: "Price",
                  data: [],
                  borderColor: "#3b82f6",
                  backgroundColor: "rgba(59, 130, 246, 0.1)",
                  tension: 0.4,
                  fill: true,
                  pointRadius: 0,
                  pointHoverRadius: 5,
                  borderWidth: 2,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  labels: { color: "#f1f5f9" },
                },
              },
              scales: {
                x: {
                  ticks: { color: "#94a3b8" },
                  grid: { color: "#334155" },
                },
                y: {
                  ticks: {
                    color: "#94a3b8",
                    callback: function (value) {
                      return "$" + value.toFixed(2);
                    },
                  },
                  grid: { color: "#334155" },
                },
              },
              interaction: {
                intersect: false,
                mode: "index",
              },
            },
          });
        }

        async startDataPolling() {
          // Simulate connection to backend
          this.updateConnectionStatus("connecting", "Connecting to backend...");

          // Simulate initial connection delay
          setTimeout(() => {
            this.updateConnectionStatus("connected", "Connected to backend");
            this.updateAlgorithmStatus("connected", "Algorithm Active");
            this.updateDataStatus(
              "connected",
              "Receiving live data from backend"
            );

            // Start polling for real data
            this.pollBackendData();
          }, 2000);
        }

        async pollBackendData() {
          // TODO: Replace with actual backend API calls
          // Example endpoints:
          // - GET /api/signals - Get recent signals
          // - GET /api/price - Get current price data
          // - GET /api/status - Get algorithm status
          // - GET /api/metrics - Get performance metrics

          try {
            // Simulate API calls (replace with actual fetch calls)
            // const signalsResponse = await fetch('/api/signals');
            // const priceResponse = await fetch('/api/price');
            // const statusResponse = await fetch('/api/status');

            // For demo purposes, generate some sample data
            this.generateSampleData();
          } catch (error) {
            console.error("Error fetching backend data:", error);
            this.updateConnectionStatus("error", "Connection failed");
          }

          // Continue polling every 5 seconds
          setTimeout(() => this.pollBackendData(), 5000);
        }

        generateSampleData() {
          // Generate sample price data
          const now = new Date();
          const price = 50000 + Math.random() * 1000 - 500;
          this.currentPrice = price;

          // Update chart
          this.chart.data.labels.push(now.toLocaleTimeString());
          this.chart.data.datasets[0].data.push(price);

          // Keep only last 50 data points
          if (this.chart.data.labels.length > 50) {
            this.chart.data.labels.shift();
            this.chart.data.datasets[0].data.shift();
          }

          this.chart.update("none");

          // Update current price display
          document.getElementById("current-price").textContent =
            "$" + price.toFixed(2);

          // Randomly generate signals
          if (Math.random() < 0.1) {
            // 10% chance of signal
            const signalType = Math.random() > 0.5 ? "BUY" : "SELL";
            this.addSignal(signalType, price, now);
          }

          this.updateStats();
        }

        addSignal(type, price, timestamp) {
          const signal = {
            type,
            price,
            timestamp,
            strength: (Math.random() * 5 + 1).toFixed(2),
          };

          this.signals.unshift(signal);
          if (this.signals.length > 50) this.signals.pop();

          this.updateSignalLog();
          this.updateStats();
        }

        updateSignalLog() {
          const logElement = document.getElementById("signal-log");

          if (this.signals.length === 0) {
            logElement.innerHTML = `
                        <div class="empty-state">
                            <i class="fas fa-signal" style="font-size: 2rem; margin-bottom: 1rem; opacity: 0.5;"></i>
                            <div>No signals received yet</div>
                            <div style="font-size: 0.875rem; margin-top: 0.5rem;">Waiting for backend algorithm...</div>
                        </div>
                    `;
            return;
          }

          logElement.innerHTML = this.signals
            .map(
              (signal) => `
                    <div class="signal-item">
                        <div class="signal-left">
                            <span class="signal-type signal-${signal.type.toLowerCase()}">${
                signal.type
              }</span>
                            <span class="signal-price">$${signal.price.toFixed(
                              2
                            )}</span>
                            <span class="signal-strength">Strength: ${
                              signal.strength
                            }</span>
                        </div>
                        <div class="signal-time">${signal.timestamp.toLocaleString()}</div>
                    </div>
                `
            )
            .join("");
        }

        updateStats() {
          const buySignals = this.signals.filter(
            (s) => s.type === "BUY"
          ).length;
          const sellSignals = this.signals.filter(
            (s) => s.type === "SELL"
          ).length;
          const lastSignal = this.signals.length > 0 ? this.signals[0] : null;

          document.getElementById("total-signals").textContent =
            this.signals.length;
          document.getElementById("last-signal").textContent = lastSignal
            ? lastSignal.type
            : "--";
          document.getElementById("signal-time").textContent = lastSignal
            ? this.getTimeAgo(lastSignal.timestamp)
            : "--";

          // Update performance metrics
          document.getElementById("win-rate").textContent =
            this.signals.length > 0
              ? Math.floor(Math.random() * 30 + 60) + "%"
              : "--%";
          document.getElementById("total-trades").textContent =
            this.signals.length;
          document.getElementById("last-update").textContent =
            new Date().toLocaleTimeString();
        }

        getTimeAgo(timestamp) {
          const now = new Date();
          const diff = now - timestamp;
          const minutes = Math.floor(diff / 60000);
          const hours = Math.floor(minutes / 60);

          if (hours > 0) return `${hours}h ago`;
          if (minutes > 0) return `${minutes}m ago`;
          return "Just now";
        }

        updateConnectionStatus(status, message) {
          const statusDot = document.getElementById("connection-status");
          const statusText = document.getElementById("connection-text");

          statusDot.className = `status-dot ${status}`;
          statusText.textContent = message;
          this.isConnected = status === "connected";
        }

        updateAlgorithmStatus(status, message) {
          const statusDot = document.getElementById("algo-status");
          const statusText = document.getElementById("algo-text");

          statusDot.className = `status-dot ${status}`;
          statusText.textContent = message;
        }

        updateDataStatus(status, message) {
          const statusElement = document.getElementById("data-status");
          const statusText = document.getElementById("data-status-text");

          statusElement.className = `data-status ${status}`;
          statusText.textContent = message;
        }
      }

      // Navigation
      function switchSection(sectionName) {
        // Remove active class from all nav links
        document.querySelectorAll(".nav-link").forEach((link) => {
          link.classList.remove("active");
        });

        // Add active class to clicked link
        document
          .querySelector(`[data-section="${sectionName}"]`)
          .classList.add("active");

        // Update dashboard title based on section
        const titles = {
          overview: "Market Overview",
          signals: "Trading Signals",
          performance: "Performance Analytics",
          data: "Data Sources",
        };

        document.querySelector(".dashboard-title").textContent =
          titles[sectionName] || "Trading Dashboard";
      }

      // Event listeners
      document.addEventListener("DOMContentLoaded", function () {
        // Initialize dashboard
        const dashboard = new DashboardManager();

        // Navigation event listeners
        document.querySelectorAll(".nav-link").forEach((link) => {
          link.addEventListener("click", function (e) {
            e.preventDefault();
            const section = this.getAttribute("data-section");
            switchSection(section);
          });
        });
      });

      // Utility functions
      function toggleTimeframe(timeframe) {
        // TODO: Implement timeframe switching
        console.log("Switching to timeframe:", timeframe);
      }

      function refreshSignals() {
        // Force refresh of signals from backend
        console.log("Refreshing signals...");

        // Add visual feedback
        const refreshBtn = document.querySelector(
          'button[onclick="refreshSignals()"]'
        );
        const originalHTML = refreshBtn.innerHTML;
        refreshBtn.innerHTML =
          '<i class="fas fa-spinner fa-spin"></i> Refreshing...';

        // Simulate API call delay
        setTimeout(() => {
          refreshBtn.innerHTML = originalHTML;
          // In real implementation, this would fetch fresh data from backend
          console.log("Signals refreshed");
        }, 1000);
      }

      function exportData() {
        // Export current dashboard data
        const data = {
          signals: dashboard.signals,
          currentPrice: dashboard.currentPrice,
          timestamp: new Date().toISOString(),
          performance: {
            totalSignals: dashboard.signals.length,
            winRate: document.getElementById("win-rate").textContent,
            totalTrades: document.getElementById("total-trades").textContent,
          },
        };

        const blob = new Blob([JSON.stringify(data, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `trading-data-${
          new Date().toISOString().split("T")[0]
        }.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      function resetDashboard() {
        if (confirm("Are you sure you want to reset all dashboard data?")) {
          // Clear all data
          dashboard.signals = [];
          dashboard.priceData = [];
          dashboard.chart.data.labels = [];
          dashboard.chart.data.datasets[0].data = [];
          dashboard.chart.update();

          // Reset UI elements
          document.getElementById("current-price").textContent = "$0.00";
          document.getElementById("total-signals").textContent = "0";
          document.getElementById("last-signal").textContent = "--";
          document.getElementById("signal-time").textContent = "--";

          dashboard.updateSignalLog();
          console.log("Dashboard reset");
        }
      }

      // Advanced Chart Functions
      function updateChartTimeframe(timeframe) {
        // TODO: Implement different timeframe data fetching
        // This would typically involve:
        // 1. Fetching historical data for the selected timeframe
        // 2. Updating the chart with new data
        // 3. Adjusting chart settings (intervals, labels, etc.)

        console.log(`Updating chart to ${timeframe} timeframe`);

        // Example implementation for different timeframes
        const timeframes = {
          "1h": { interval: 60000, points: 60 }, // 1 minute intervals, 60 points
          "4h": { interval: 240000, points: 60 }, // 4 minute intervals, 60 points
          "1d": { interval: 1440000, points: 60 }, // 24 minute intervals, 60 points
        };

        const config = timeframes[timeframe];
        if (config) {
          // Update chart configuration
          dashboard.chart.options.scales.x.ticks.maxTicksLimit = config.points;
          dashboard.chart.update();
        }
      }

      // WebSocket Connection (for real-time data)
      function initializeWebSocket() {
        // TODO: Implement WebSocket connection to backend
        // Example WebSocket setup:
        /*
                const ws = new WebSocket('ws://localhost:8080/ws');
                
                ws.onopen = function(event) {
                    console.log('WebSocket connected');
                    dashboard.updateConnectionStatus('connected', 'Real-time connection active');
                };
                
                ws.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    
                    switch(data.type) {
                        case 'price_update':
                            dashboard.updatePrice(data.price);
                            break;
                        case 'new_signal':
                            dashboard.addSignal(data.signal.type, data.signal.price, new Date(data.signal.timestamp));
                            break;
                        case 'status_update':
                            dashboard.updateAlgorithmStatus(data.status, data.message);
                            break;
                    }
                };
                
                ws.onclose = function(event) {
                    console.log('WebSocket disconnected');
                    dashboard.updateConnectionStatus('disconnected', 'Connection lost - attempting to reconnect...');
                    
                    // Attempt to reconnect after 5 seconds
                    setTimeout(() => {
                        initializeWebSocket();
                    }, 5000);
                };
                
                ws.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    dashboard.updateConnectionStatus('error', 'Connection error');
                };
                */
      }

      // API Integration Functions
      class APIManager {
        constructor(baseUrl = "http://localhost:8080") {
          this.baseUrl = baseUrl;
          this.apiKey = ""; // TODO: Implement API key management
        }

        async fetchSignals(limit = 50) {
          try {
            const response = await fetch(
              `${this.baseUrl}/api/signals?limit=${limit}`,
              {
                headers: {
                  Authorization: `Bearer ${this.apiKey}`,
                  "Content-Type": "application/json",
                },
              }
            );

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
          } catch (error) {
            console.error("Error fetching signals:", error);
            throw error;
          }
        }

        async fetchCurrentPrice() {
          try {
            const response = await fetch(`${this.baseUrl}/api/price`, {
              headers: {
                Authorization: `Bearer ${this.apiKey}`,
                "Content-Type": "application/json",
              },
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
          } catch (error) {
            console.error("Error fetching price:", error);
            throw error;
          }
        }

        async fetchHistoricalData(timeframe = "1h", limit = 100) {
          try {
            const response = await fetch(
              `${this.baseUrl}/api/historical?timeframe=${timeframe}&limit=${limit}`,
              {
                headers: {
                  Authorization: `Bearer ${this.apiKey}`,
                  "Content-Type": "application/json",
                },
              }
            );

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
          } catch (error) {
            console.error("Error fetching historical data:", error);
            throw error;
          }
        }

        async fetchPerformanceMetrics() {
          try {
            const response = await fetch(`${this.baseUrl}/api/metrics`, {
              headers: {
                Authorization: `Bearer ${this.apiKey}`,
                "Content-Type": "application/json",
              },
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
          } catch (error) {
            console.error("Error fetching performance metrics:", error);
            throw error;
          }
        }

        async updateAlgorithmSettings(settings) {
          try {
            const response = await fetch(`${this.baseUrl}/api/settings`, {
              method: "POST",
              headers: {
                Authorization: `Bearer ${this.apiKey}`,
                "Content-Type": "application/json",
              },
              body: JSON.stringify(settings),
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
          } catch (error) {
            console.error("Error updating algorithm settings:", error);
            throw error;
          }
        }
      }

      // Notification System
      class NotificationManager {
        constructor() {
          this.notifications = [];
          this.container = this.createNotificationContainer();
        }

        createNotificationContainer() {
          const container = document.createElement("div");
          container.id = "notification-container";
          container.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        z-index: 1000;
                        max-width: 400px;
                    `;
          document.body.appendChild(container);
          return container;
        }

        show(message, type = "info", duration = 5000) {
          const notification = document.createElement("div");
          notification.className = `notification notification-${type}`;
          notification.style.cssText = `
                        background: var(--surface);
                        border: 1px solid var(--border);
                        border-radius: 8px;
                        padding: 1rem;
                        margin-bottom: 0.5rem;
                        box-shadow: var(--shadow-lg);
                        opacity: 0;
                        transform: translateX(100%);
                        transition: all 0.3s ease;
                        position: relative;
                        border-left: 4px solid ${this.getTypeColor(type)};
                    `;

          notification.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <i class="fas ${this.getTypeIcon(
                              type
                            )}" style="color: ${this.getTypeColor(type)};"></i>
                            <span style="color: var(--text-primary); flex: 1;">${message}</span>
                            <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 1.2rem;">&times;</button>
                        </div>
                    `;

          this.container.appendChild(notification);

          // Animate in
          setTimeout(() => {
            notification.style.opacity = "1";
            notification.style.transform = "translateX(0)";
          }, 100);

          // Auto remove
          if (duration > 0) {
            setTimeout(() => {
              notification.style.opacity = "0";
              notification.style.transform = "translateX(100%)";
              setTimeout(() => {
                if (notification.parentElement) {
                  notification.remove();
                }
              }, 300);
            }, duration);
          }
        }

        getTypeColor(type) {
          const colors = {
            success: "var(--success-color)",
            error: "var(--danger-color)",
            warning: "var(--warning-color)",
            info: "var(--info-color)",
          };
          return colors[type] || colors.info;
        }

        getTypeIcon(type) {
          const icons = {
            success: "fa-check-circle",
            error: "fa-exclamation-circle",
            warning: "fa-exclamation-triangle",
            info: "fa-info-circle",
          };
          return icons[type] || icons.info;
        }
      }

      // Initialize managers
      let dashboard, apiManager, notificationManager;

      // Enhanced initialization
      document.addEventListener("DOMContentLoaded", function () {
        // Initialize all managers
        dashboard = new DashboardManager();
        apiManager = new APIManager();
        notificationManager = new NotificationManager();

        // Initialize WebSocket connection
        // initializeWebSocket();

        // Set up keyboard shortcuts
        setupKeyboardShortcuts();

        // Set up periodic data refresh
        setInterval(() => {
          if (dashboard.isConnected) {
            // Refresh data every 30 seconds
            dashboard.pollBackendData();
          }
        }, 30000);
      });

      // Keyboard shortcuts
      function setupKeyboardShortcuts() {
        document.addEventListener("keydown", function (e) {
          // Ctrl/Cmd + R: Refresh signals
          if ((e.ctrlKey || e.metaKey) && e.key === "r") {
            e.preventDefault();
            refreshSignals();
          }

          // Ctrl/Cmd + E: Export data
          if ((e.ctrlKey || e.metaKey) && e.key === "e") {
            e.preventDefault();
            exportData();
          }

          // Ctrl/Cmd + 1-4: Switch sections
          if ((e.ctrlKey || e.metaKey) && e.key >= "1" && e.key <= "4") {
            e.preventDefault();
            const sections = ["overview", "signals", "performance", "data"];
            switchSection(sections[parseInt(e.key) - 1]);
          }
        });
      }

      // Error handling
      window.addEventListener("error", function (e) {
        console.error("Global error:", e.error);
        notificationManager.show(`Error: ${e.error.message}`, "error");
      });

      // Unhandled promise rejections
      window.addEventListener("unhandledrejection", function (e) {
        console.error("Unhandled promise rejection:", e.reason);
        notificationManager.show(`Connection error: ${e.reason}`, "error");
      });

      // Export global functions for external use
      window.TradingDashboard = {
        dashboard,
        apiManager,
        notificationManager,
        refreshSignals,
        exportData,
        resetDashboard,
        switchSection,
      };
    </script>
  </body>
</html>
